// MFC Database Schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id          String @id @default(cuid())
  auth0Id     String @unique // Auth0 user ID
  email       String @unique
  name        String?
  username    String? @unique
  credits     Float  @default(1000.0) // Starting credits
  isAgent     Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  fighters    Fighter[]
  trainings   Training[]
  bets        Bet[]
  fightResults FightResult[]
  apiKeys     ApiKey[]
  agentProfile AgentProfile?
  skinPurchases SkinPurchase[]
  ownedAgents  AgentProfile[] @relation("AgentOwner")
  billingRequests BillingRequest[] @relation("BillingOwner")

  @@index([auth0Id])
  @@index([email])
  @@index([createdAt])
  @@map("users")
}

model Fighter {
  id            String @id @default(cuid())
  name          String
  emoji         String
  class         FighterClass
  elo           Int @default(1000)
  isActive      Boolean @default(true)
  trainingCost  Float @default(100.0)

  // Stats that improve with training
  strength      Int @default(50)
  speed         Int @default(50)
  defense       Int @default(50)
  stamina       Int @default(50)
  fightIQ       Int @default(50)
  aggression    Int @default(50)

  // Record tracking
  wins          Int @default(0)
  losses        Int @default(0)
  draws         Int @default(0)

  // Training tracking
  totalTrainingHours   Float @default(0.0)
  totalTrainingSessions Int @default(0)

  // Momentum factors
  winStreak     Int @default(0)
  lossStreak    Int @default(0)
  lastFightAt   DateTime?

  // Metadata
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relationships
  owner         User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId       String
  trainings     Training[]
  fightsAsFighter1 Fight[] @relation("Fighter1")
  fightsAsFighter2 Fight[] @relation("Fighter2")
  fightResults  FightResult[]
  bets          Bet[]
  skinPurchases SkinPurchase[]

  @@index([ownerId])
  @@index([elo(sort: Desc)])
  @@index([class, isActive])
  @@index([isActive, elo(sort: Desc)])
  @@index([createdAt])
  @@map("fighters")
}

model Training {
  id              String @id @default(cuid())
  durationMinutes Int              // 15, 20, 25, or 30
  status          TrainingStatus @default(ACTIVE)
  startedAt       DateTime @default(now())
  completedAt     DateTime?

  // Legacy fields (nullable for backward compat with old rows)
  hours           Float?
  cost            Float?

  // Stat improvements (populated on completion only)
  strengthGain    Int @default(0)
  speedGain       Int @default(0)
  defenseGain     Int @default(0)
  staminaGain     Int @default(0)
  fightIQGain     Int @default(0)
  aggressionGain  Int @default(0)

  createdAt       DateTime @default(now())

  // Relationships
  fighter     Fighter @relation(fields: [fighterId], references: [id], onDelete: Cascade)
  fighterId   String
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String

  @@index([fighterId])
  @@index([userId])
  @@index([createdAt])
  @@index([status, fighterId])
  @@map("trainings")
}

model Fight {
  id              String @id @default(cuid())
  status          FightStatus @default(SCHEDULED)
  scheduledAt     DateTime
  startedAt       DateTime?
  endedAt         DateTime?

  // Fight setup
  maxRounds       Int @default(3)
  venue           String?
  title           String?

  // Algorithm data (serialized fight state)
  fightData       Json? // Stores detailed fight simulation data

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationships
  fighter1        Fighter @relation("Fighter1", fields: [fighter1Id], references: [id])
  fighter1Id      String
  fighter2        Fighter @relation("Fighter2", fields: [fighter2Id], references: [id])
  fighter2Id      String

  result          FightResult?
  bets            Bet[]

  @@index([status])
  @@index([fighter1Id])
  @@index([fighter2Id])
  @@index([scheduledAt])
  @@index([status, scheduledAt])
  @@map("fights")
}

model FightResult {
  id          String @id @default(cuid())
  method      FightMethod // KO, TKO, Decision, etc.
  round       Int?
  time        String?

  // Stats from the fight
  fighter1Stats Json // Detailed fight stats
  fighter2Stats Json

  // ELO changes
  fighter1EloChange Int
  fighter2EloChange Int

  createdAt   DateTime @default(now())

  // Relationships
  fight       Fight @relation(fields: [fightId], references: [id], onDelete: Cascade)
  fightId     String @unique
  winner      Fighter? @relation(fields: [winnerId], references: [id])
  winnerId    String?
  user        User @relation(fields: [userId], references: [id]) // Who created this result
  userId      String

  @@index([winnerId])
  @@index([userId])
  @@index([createdAt])
  @@map("fight_results")
}

model Bet {
  id          String @id @default(cuid())
  amount      Float
  side        BetSide // YES or NO (or FIGHTER1/FIGHTER2)
  odds        Float // Odds when bet was placed
  status      BetStatus @default(PENDING)
  payout      Float?

  createdAt   DateTime @default(now())
  settledAt   DateTime?

  // Relationships
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  fight       Fight @relation(fields: [fightId], references: [id])
  fightId     String
  fighter     Fighter? @relation(fields: [fighterId], references: [id]) // If betting on specific fighter
  fighterId   String?

  @@index([userId])
  @@index([fightId])
  @@index([status])
  @@index([userId, status])
  @@index([fightId, status])
  @@index([createdAt])
  @@map("bets")
}

model ApiKey {
  id         String    @id @default(cuid())
  key        String    @unique
  userId     String
  name       String?
  active     Boolean   @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@map("api_keys")
}

model AgentProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  agentName   String
  description String?
  moltbookId  String?  @unique
  ownerId     String?  // Human user who deployed this agent
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  owner       User?    @relation("AgentOwner", fields: [ownerId], references: [id])
  billingRequests BillingRequest[]

  @@index([moltbookId])
  @@index([ownerId])
  @@map("agent_profiles")
}

model Skin {
  id            String    @id @default(cuid())
  name          String
  type          SkinType
  rarity        SkinRarity
  priceCredits  Float
  pixels        Json      // Pixel overlay data for rendering
  description   String?
  createdAt     DateTime  @default(now())

  purchases     SkinPurchase[]

  @@index([type])
  @@index([rarity])
  @@map("skins")
}

model SkinPurchase {
  id         String   @id @default(cuid())
  equipped   Boolean  @default(false)
  createdAt  DateTime @default(now())

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  skin       Skin     @relation(fields: [skinId], references: [id])
  skinId     String
  fighter    Fighter  @relation(fields: [fighterId], references: [id])
  fighterId  String

  @@unique([userId, skinId, fighterId])
  @@index([userId])
  @@index([fighterId])
  @@map("skin_purchases")
}

enum SkinType {
  BODY
  HEAD
  GLOVES
  BOOTS
  AURA
}

enum SkinRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

model BillingRequest {
  id          String   @id @default(cuid())
  amount      Float    // Requested credit amount
  reason      String   // Why the agent needs credits
  status      BillingStatus @default(PENDING)
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?

  // Relationships
  agent       AgentProfile @relation(fields: [agentId], references: [id], onDelete: Cascade)
  agentId     String
  ownerId     String   // Human owner who will approve/reject
  owner       User     @relation("BillingOwner", fields: [ownerId], references: [id])

  @@index([agentId])
  @@index([ownerId])
  @@index([status])
  @@index([createdAt])
  @@map("billing_requests")
}

enum BillingStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
}

enum FighterClass {
  LIGHTWEIGHT
  MIDDLEWEIGHT
  HEAVYWEIGHT
}

enum FightStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum FightMethod {
  KO
  TKO
  DECISION
  SUBMISSION
  DISQUALIFICATION
  NO_CONTEST
}

enum BetSide {
  YES
  NO
  FIGHTER1
  FIGHTER2
  OVER
  UNDER
}

enum BetStatus {
  PENDING
  WON
  LOST
  CANCELLED
  REFUNDED
}

enum TrainingStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}
